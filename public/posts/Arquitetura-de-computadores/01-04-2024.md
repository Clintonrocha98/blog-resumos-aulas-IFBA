---
title: Resumo da aula de Arquitetura de computadores
date: 01-04-2024
excerpt: Resumo da aula.
---

# Resumo

Teve uma aula pratica sobre compila√ß√£o. N√£o sei se o conteudo que o professor passou no notion vai ficar para sempre, ent√£o vou passar para aqui.

# IFBA - Arquitetura de Computadores - Performance

O objetivo dessa aula pr√°tica √©, atrav√©s de experimentos, consolidar os conceitos te√≥ricos discutidos em sala relacionados ao tema de performance. Veremos como a **linguagem de programa√ß√£o**, o **compilador** e o **processador** podem afetar a performance de uma aplica√ß√£o. Em suma, voc√™s teram a oportunidade de ver em um experimento pr√°tico como diferentes aspectos tanto de **software** quanto de **hardware** impactam no desempenho final de uma aplica√ß√£o.

O seu relat√≥rio deve seguir minimamente o padr√£o contido no arquivo abaixo. Duplique o arquivo no seu google drive e fa√ßa as devidas altera√ß√µes:

[Modelo do relatorio de performance](https://docs.google.com/document/d/14WLG6IAeWgsHaOOgwaIzAa9M-ORuotYZ/edit?usp=sharing&ouid=114578416706894453387&rtpof=true&sd=true)

Usaremos para essa atividade alguma distribui√ß√£o linux com as seguintes ferramentas instaladas:

# perf

```bash
sudo apt-get install linux-tools-$(uname -r) linux-tools-generic -y
```

```bash
~~sudo sh -c 'echo 1 >/proc/sys/kernel/perf_event_paranoid'~~
```

Just to check if is running correctly

```bash
sudo perf stat -e cycles, instructions sleep 3
```

Outra op√ß√£o √© criar o pendrive boot√°vel. Tem uma imagem que parece j√° vir com o perf:

linuxmint-21.1-cinnamon-64bit.iso

# cpufrequtils

Primeiro o comando para instala√ß√£o:

````bash
sudo apt install cpufrequtils
```‚Äã

Depois adicionar a linha no /etc/sudoers para permitir que apenas esse comando seja poss√≠vel executar sem privil√©gios de super usu√°rio:

```bash
aluno ALL=(ALL) NOPASSWD: /usr/bin/perf
aluno ALL=(ALL) NOPASSWD: /usr/bin/cpufreq-set *
````

‚Äã
Verifique se ao configurar os seguintes modos de opera√ß√£o, se as frequ√™ncias s√£o alteradas:

```bash
sudo cpufreq-set -r -g performance
```

‚Äã
O modo ‚Äúperformance‚Äù configura as CPUs para a frequ√™ncia m√°xima.

````bash
sudo cpufreq-set -r -g powersave
```‚Äã

O modo ‚Äúpowersave‚Äù configura as CPUs para a frequ√™ncia m√≠nima. Vale destacar que nem todo hardware suporta a configura√ß√£o de frequ√™ncias extremamente baixas. Muitas vezes nessa configura√ß√£o o sistema tentar√° manter a frequ√™ncia do processador o mais baixa poss√≠vel, dependendo da carga de trabalho, para economizar energia.
O comando abaixo √© poss√≠vel monitorar a frequ√™ncia a cada 2 segundos:

```bash
watch cat /sys/devices/system/cpu/cpu[0-9]*/cpufreq/scaling_cur_freq
````

Apenas para recapitular, a performance de uma aplica√ß√£o √© influenciada por in√∫meros elementos. A Figura a seguir exemplifica os principais:

![imagem da performance](/public/imgs/performance.png)

Esses elementos se traduzem na seguinte equa√ß√£o:

![calculo de performance](/public/imgs/calculo.png)

Dado essas informa√ß√µes, voc√™s ir√£o iniciar uma atividade pr√°tica a qual deve ser registrada em um arquivo em PDF todas as respostas solicitadas.

# Pr√°tica 1 - Diferentes Linguagens de Programa√ß√£o

Usando algum editor de texto ou alguma IDE,  crie o seguinte programa em **linguagem C** para calcular a soma dos primeiros 1 bilh√£o de n√∫meros naturais . Em seguida, salve com a extens√£o ‚Äú.c‚Äù .

```C
#include <stdio.h>

long long unsigned int sum(long unsigned int  n) {
    long long unsigned int s = 0;
    long int i;
    for (i = 1; i <= n; ++i) {
        s += i;
    }
    return s;
}

int main() {
    long int n = 1e+9;
    printf("sum(%ld) = %llu\n", n, sum(n));
    return 0;
}
```

Depois voc√™ ir√° compilar o seu c√≥digo-fonte no terminal usando o compilador chamado GCC. Use o seguinte comando:

```shell
# Toda linha que iniciar com o s√≠mbolo # √© apenas um coment√°rio
# gcc √© o nome do compilador
# -o significa output
# prog √© o nome que eu escolhi, pode ser qualquer outro
# arquivo.c √© o nome do seu arquivo com o c√≥digo C
# Resumindo o comando: gcc -o [nome_do_execut√°vel] [nome_arquivo].c

gcc -o prog arquivo.c
```

Para **executar** o programa gerado, basta executar o comando a seguir no **terminal**, trocando apenas o ‚Äúprog‚Äù pelo nome que voc√™ deu para o seu execut√°vel.

```bash
./prog
```

Se tudo ocorrer bem, voc√™ ver√° a sa√≠da da soma no terminal. 

Entretanto, voc√™ n√£o calculou ainda nenhuma m√©trica. Para calcular a m√©trica de tempo de execu√ß√£o(ou execution time), vamos executar o programa usando quase o mesmo comando anterior, por√©m adicionando o comando **time** antes do programa, conforme a seguir:

```bash
time ./prog
```

A partir de pesquisas na internet, explique usando as suas pr√≥prias palavras as seguintes perguntas:

- **(1) Qual a diferen√ßa entre real time, user time e system time.**
- **(2) Quais desses valores voc√™s ir√£o usar como refer√™ncia para o tempo de execu√ß√£o de um programa? Porque ?**

Agora iremos implementar o mesmo algoritmo, por√©m usando a linguagem de programa√ß√£o **python**. Crie o seguinte programa em python e salve com a extens√£o ‚Äú.py‚Äù:

```python
def sum(n):
    s = 0
    for i in range(1, n + 1):
        s += i
    return s

n = int(1e9)
print("sum({}) = {}".format(n, sum(n)))
```

Devido a linguagem python ser **interpretada**, ao inv√©s de **compilada**, n√£o se gera nenhum execut√°vel. Voc√™ apenas encaminha o seu c√≥digo-fonte para o interpretador executar o seu programa. Para executar portanto um programa em python execute o seguinte comando no **terminal**:

```bash
python3 programa.py
```

Substitua ‚Äùprograma.py‚Äù para o nome dado ao seu c√≥digo fonte. Para calcular o tempo de execu√ß√£o, basta colocar o time antes do comando:

```bash
time python3 programa.py
```

Confirme se a saida tanto do programa em C quanto em Python, est√£o com o mesmo resultado. Afinal, eles fazem a mesma coisa. üòÉ 

Responda as seguintes perguntas:

- **(3) Informe a diferen√ßa de performance entre os dois programas usando a m√©dia (de pelo menos 3 execu√ß√µes) e o desvio padr√£o.**
    
>[Desvio Padr√£o](https://www.notion.so/Desvio-Padr-o-72f3b6b3c9c6435a8d82c3ff8094e75d?pvs=21)
    
- **(4) Informe por quais raz√µes a linguagem C teve uma melhor performance comparado a linguagem Python?**

# Pr√°tica 2 - Diferentes Compiladores

O prop√≥sito do segundo experimento √© **ainda** analisar o impacto que o **software** tem sobre a performance de uma aplica√ß√£o. Para isso, n√≥s vamos usar o **mesmo algoritmo**, a **mesma linguagem de programa√ß√£o**, por√©m iremos **simular** **compiladores diferente**s, mudando o **tipo de compila√ß√£o**.

Iremos usar o programa j√° criado na linguagem C e mudaremos uma flag que visa otimizar o c√≥digo gerado durante o processo de compila√ß√£o. Ou seja, iremos usar o mesmo algoritmo, a mesma linguagem de programa√ß√£o, e iremos mudar a forma como o compilador ir√° gerar o c√≥digo execut√°vel.

Na primeira execu√ß√£o use a flag -O0(o que n√£o implementa nenhum otimiza√ß√£o), enquanto na segunda execu√ß√£o iremos aplicar a otimiza√ß√£o -O4 (o que significa otimiza√ß√£o agressiva). Ent√£o execute os seguintes comandos para realizar o processo de compila√ß√£o:

```bash
# Novamente, prog0 e prog4 foram os nomes que eu utilizei. Poderia ser qualquer 
#outro nome.
# prog0 foi porque n√£o tem nenhuma otimiza√ß√£o
# prog4 foi porque eu usei a otimiza√ß√£o m√°xima, no caso √© 4

gcc -o prog0 -O0 arquivo.c
gcc -o prog4 -O4 arquivo.c
```

- **(1) Informe a diferen√ßa de performance entre os dois programas usando a m√©dia (de pelo menos 3 execu√ß√µes) e o desvio padr√£o para ambas m√©tricas (tempo de execu√ß√£o e IPC).**

Para isso, use a ferramenta **perf**, que oferece informa√ß√µes tanto do IPC (instru√ß√µes por ciclo) quanto de tempo de execu√ß√£o.¬† Para isso execute o comando:

```bash
sudo perf stat -e instructions,cycles ./prog0
sudo perf stat -e instructions,cycles ./prog4
```

- **(2) O que voc√™ acha que pode mudar entre uma otimiza√ß√£o e outra ? Pesquise porque nem sempre os programas s√£o compilados com a otimiza√ß√£o m√°xima ?**
- **(3) Aproveite as informa√ß√µes dadas pelo perf como a m√©trica IPC, total instru√ß√µes e total de ciclos para verificar se o resultado do tempo de execu√ß√£o se aproxima da f√≥rmula descrita inicialmente nesse documento.**
    - Lembre-se que o perf ir√° mostrar a m√©trica IPC, por√©m a f√≥rmula usa CPI. Para fazer a convers√£o basta fazer a seguinte conta: CPI = 1/IPC.
    
> [Estimando o Tempo de 1 Ciclo](https://www.notion.so/Estimando-o-Tempo-de-1-Ciclo-e4ede2b68beb480595ce4a9b32ce0c6a?pvs=21)

# Pr√°tica 3 - Diferentes Processadores

O prop√≥sito do terceiro experimento √© analisar o impacto que o **hardware** tem sobre a performance de uma aplica√ß√£o. Para isso, n√≥s vamos usar o **mesmo tipo de algoritmo**, o **mesmo tipo de linguagem de programa√ß√£o**, **o mesmo processo de compila√ß√£o**, por√©m **simularemos dois hardwares diferentes**. Mudaremos apenas um item do hardware, a sua frequ√™ncia de trabalho.

Cada CPU possui uma lista de frequ√™ncia √†s quais ele suporta trabalhar. N√≥s iremos usar duas dessas frequ√™ncias. A frequ√™ncia menor para simular um hardware mais "fraco"e depois n√≥s iremos usar a frequ√™ncia maior para simular um hardware mais "forte". Para listar as frequ√™ncias suportadas, utilize o seguinte comando no **terminal**:

```bash
cpufreq-info
```

Antes de configurar uma frequ√™ncia espec√≠fica, mudaremos a pol√≠tica de configura√ß√£o de frequ√™ncia para trabalhar de maneira fixa e n√£o din√¢mica como normalmente √© o comportamento padr√£o. Para isso, execute no terminal o seguinte comando, mudando a pol√≠tica para **performance**.

```bash
sudo cpufreq-set -r -g performance
```

Confirme atrav√©s do comando abaixo que a frequ√™ncia est√° na m√°xima.

```bash
watch cat /sys/devices/system/cpu/cpu[0-9]*/cpufreq/scaling_cur_freq
```

Se por algum motivo a configura√ß√£o n√£o surtir efeito, voc√™ pode tentar atrav√©s de um aplicativo com interface chamado **cpupower-GUI** usando os links abaixo. Por√©m, caso esteja funcionando, apenas pule essa etapa.

[cpupower-GUI](https://github.com/vagnum08/cpupower-gui/releases/)

Aqui algumas instru√ß√µes de como instal√°-lo:

[cpupower-gui-simple-tool-adjust-cpu-frequency](https://ubuntuhandbook.org/index.php/2020/11/cpupower-gui-simple-tool-adjust-cpu-frequency/)

Em seguida voc√™ deve rodar o seu programa em C feito em **Pr√°tica 1** e coletar o tempo de execu√ß√£o.

```bash
time ./prog 
```

Depois, voc√™ deve repetir esse processo, por√©m configurando a CPU para trabalhar na frequ√™ncia m√≠nima. Para isso mude a pol√≠tica para **powersave**.

```bash
# Assumindo que a frequ√™ncia m√°xima seja 3.6GHz
sudo cpufreq-set -r -g powersave
```

Confirme atrav√©s do comando abaixo que a frequ√™ncia est√° na m√≠nima.

```bash
watch cat /sys/devices/system/cpu/cpu[0-9]*/cpufreq/scaling_cur_freq
```

Novamente voc√™ deve coletar o tempo de execu√ß√£o e depois comparar qual foi o ganho de performance entre as duas execu√ß√µes.

```bash
time ./prog
```

- **(1) Informe a diferen√ßa de performance entre as duas execu√ß√µes, usando a m√©dia (de pelo menos 3 execu√ß√µes) e apresente tamb√©m o desvio padr√£o dos resultados.**
- **(2) Como foi a diferen√ßa de performance em rela√ß√£o a diferen√ßa de frequencia ?**

√â importante destacar que a frequ√™ncia da CPU afeta a velocidade de execu√ß√£o das instru√ß√µes e, consequentemente, o tempo total de execu√ß√£o do programa. Ela n√£o afeta o n√∫mero absoluto de instru√ß√µes em um programa, mas pode influenciar a quantidade de instru√ß√µes executadas em um determinado per√≠odo de tempo.

Ao final, deixe a frequencia de trabalho din√¢mica, usando o seguinte comando:

```bash
sudo cpufreq-set -r -g ondemand
```