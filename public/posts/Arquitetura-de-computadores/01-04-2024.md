---
title: Resumo da aula de Arquitetura de computadores
date: 01-04-2024
excerpt: Resumo da aula.
---

# Resumo

Teve uma aula pratica sobre compilaÃ§Ã£o. NÃ£o sei se o conteudo que o professor passou no notion vai ficar para sempre, entÃ£o vou passar para aqui.

# IFBA - Arquitetura de Computadores - Performance

O objetivo dessa aula prÃ¡tica Ã©, atravÃ©s de experimentos, consolidar os conceitos teÃ³ricos discutidos em sala relacionados ao tema de performance. Veremos como a **linguagem de programaÃ§Ã£o**, o **compilador** e o **processador** podem afetar a performance de uma aplicaÃ§Ã£o. Em suma, vocÃªs teram a oportunidade de ver em um experimento prÃ¡tico como diferentes aspectos tanto de **software** quanto de **hardware** impactam no desempenho final de uma aplicaÃ§Ã£o.

O seu relatÃ³rio deve seguir minimamente o padrÃ£o contido no arquivo abaixo. Duplique o arquivo no seu google drive e faÃ§a as devidas alteraÃ§Ãµes:

[Modelo do relatorio de performance](https://docs.google.com/document/d/14WLG6IAeWgsHaOOgwaIzAa9M-ORuotYZ/edit?usp=sharing&ouid=114578416706894453387&rtpof=true&sd=true)

Usaremos para essa atividade alguma distribuiÃ§Ã£o linux com as seguintes ferramentas instaladas:

# perf

```bash
sudo apt-get install linux-tools-$(uname -r) linux-tools-generic -y
```

```bash
~~sudo sh -c 'echo 1 >/proc/sys/kernel/perf_event_paranoid'~~
```

Just to check if is running correctly

```bash
sudo perf stat -e cycles, instructions sleep 3
```

Outra opÃ§Ã£o Ã© criar o pendrive bootÃ¡vel. Tem uma imagem que parece jÃ¡ vir com o perf:

linuxmint-21.1-cinnamon-64bit.iso

# cpufrequtils

Primeiro o comando para instalaÃ§Ã£o:

````bash
sudo apt install cpufrequtils
```â€‹

Depois adicionar a linha no /etc/sudoers para permitir que apenas esse comando seja possÃ­vel executar sem privilÃ©gios de super usuÃ¡rio:

```bash
aluno ALL=(ALL) NOPASSWD: /usr/bin/perf
aluno ALL=(ALL) NOPASSWD: /usr/bin/cpufreq-set *
````

â€‹
Verifique se ao configurar os seguintes modos de operaÃ§Ã£o, se as frequÃªncias sÃ£o alteradas:

```bash
sudo cpufreq-set -r -g performance
```

â€‹
O modo â€œperformanceâ€ configura as CPUs para a frequÃªncia mÃ¡xima.

````bash
sudo cpufreq-set -r -g powersave
```â€‹

O modo â€œpowersaveâ€ configura as CPUs para a frequÃªncia mÃ­nima. Vale destacar que nem todo hardware suporta a configuraÃ§Ã£o de frequÃªncias extremamente baixas. Muitas vezes nessa configuraÃ§Ã£o o sistema tentarÃ¡ manter a frequÃªncia do processador o mais baixa possÃ­vel, dependendo da carga de trabalho, para economizar energia.
O comando abaixo Ã© possÃ­vel monitorar a frequÃªncia a cada 2 segundos:

```bash
watch cat /sys/devices/system/cpu/cpu[0-9]*/cpufreq/scaling_cur_freq
````

Apenas para recapitular, a performance de uma aplicaÃ§Ã£o Ã© influenciada por inÃºmeros elementos. A Figura a seguir exemplifica os principais:

![imagem da performance](/public/imgs/performance.png)

Esses elementos se traduzem na seguinte equaÃ§Ã£o:

![calculo de performance](/public/imgs/calculo.png)

Dado essas informaÃ§Ãµes, vocÃªs irÃ£o iniciar uma atividade prÃ¡tica a qual deve ser registrada em um arquivo em PDF todas as respostas solicitadas.

# PrÃ¡tica 1 - Diferentes Linguagens de ProgramaÃ§Ã£o

Usando algum editor de texto ou alguma IDE,  crie o seguinte programa em **linguagem C** para calcular a soma dos primeiros 1 bilhÃ£o de nÃºmeros naturais . Em seguida, salve com a extensÃ£o â€œ.câ€ .

```C
#include <stdio.h>

long long unsigned int sum(long unsigned int  n) {
    long long unsigned int s = 0;
    long int i;
    for (i = 1; i <= n; ++i) {
        s += i;
    }
    return s;
}

int main() {
    long int n = 1e+9;
    printf("sum(%ld) = %llu\n", n, sum(n));
    return 0;
}
```

Depois vocÃª irÃ¡ compilar o seu cÃ³digo-fonte no terminal usando o compilador chamado GCC. Use o seguinte comando:

```shell
# Toda linha que iniciar com o sÃ­mbolo # Ã© apenas um comentÃ¡rio
# gcc Ã© o nome do compilador
# -o significa output
# prog Ã© o nome que eu escolhi, pode ser qualquer outro
# arquivo.c Ã© o nome do seu arquivo com o cÃ³digo C
# Resumindo o comando: gcc -o [nome_do_executÃ¡vel] [nome_arquivo].c

gcc -o prog arquivo.c
```

Para **executar** o programa gerado, basta executar o comando a seguir no **terminal**, trocando apenas o â€œprogâ€ pelo nome que vocÃª deu para o seu executÃ¡vel.

```bash
./prog
```

Se tudo ocorrer bem, vocÃª verÃ¡ a saÃ­da da soma no terminal. 

Entretanto, vocÃª nÃ£o calculou ainda nenhuma mÃ©trica. Para calcular a mÃ©trica de tempo de execuÃ§Ã£o(ou execution time), vamos executar o programa usando quase o mesmo comando anterior, porÃ©m adicionando o comando **time** antes do programa, conforme a seguir:

```bash
time ./prog
```

A partir de pesquisas na internet, explique usando as suas prÃ³prias palavras as seguintes perguntas:

- **(1) Qual a diferenÃ§a entre real time, user time e system time.**
- **(2) Quais desses valores vocÃªs irÃ£o usar como referÃªncia para o tempo de execuÃ§Ã£o de um programa? Porque ?**

Agora iremos implementar o mesmo algoritmo, porÃ©m usando a linguagem de programaÃ§Ã£o **python**. Crie o seguinte programa em python e salve com a extensÃ£o â€œ.pyâ€:

```python
def sum(n):
    s = 0
    for i in range(1, n + 1):
        s += i
    return s

n = int(1e9)
print("sum({}) = {}".format(n, sum(n)))
```

Devido a linguagem python ser **interpretada**, ao invÃ©s de **compilada**, nÃ£o se gera nenhum executÃ¡vel. VocÃª apenas encaminha o seu cÃ³digo-fonte para o interpretador executar o seu programa. Para executar portanto um programa em python execute o seguinte comando no **terminal**:

```bash
python3 programa.py
```

Substitua â€programa.pyâ€ para o nome dado ao seu cÃ³digo fonte. Para calcular o tempo de execuÃ§Ã£o, basta colocar o time antes do comando:

```bash
time python3 programa.py
```

Confirme se a saida tanto do programa em C quanto em Python, estÃ£o com o mesmo resultado. Afinal, eles fazem a mesma coisa. ğŸ˜ƒ 

Responda as seguintes perguntas:

- **(3) Informe a diferenÃ§a de performance entre os dois programas usando a mÃ©dia (de pelo menos 3 execuÃ§Ãµes) e o desvio padrÃ£o.**
    [Desvio PadrÃ£o](https://www.notion.so/Desvio-Padr-o-72f3b6b3c9c6435a8d82c3ff8094e75d?pvs=21)
    
- **(4) Informe por quais razÃµes a linguagem C teve uma melhor performance comparado a linguagem Python?**

# PrÃ¡tica 2 - Diferentes Compiladores

O propÃ³sito do segundo experimento Ã© **ainda** analisar o impacto que o **software** tem sobre a performance de uma aplicaÃ§Ã£o. Para isso, nÃ³s vamos usar o **mesmo algoritmo**, a **mesma linguagem de programaÃ§Ã£o**, porÃ©m iremos **simular** **compiladores diferente**s, mudando o **tipo de compilaÃ§Ã£o**.

Iremos usar o programa jÃ¡ criado na linguagem C e mudaremos uma flag que visa otimizar o cÃ³digo gerado durante o processo de compilaÃ§Ã£o. Ou seja, iremos usar o mesmo algoritmo, a mesma linguagem de programaÃ§Ã£o, e iremos mudar a forma como o compilador irÃ¡ gerar o cÃ³digo executÃ¡vel.

Na primeira execuÃ§Ã£o use a flag -O0(o que nÃ£o implementa nenhum otimizaÃ§Ã£o), enquanto na segunda execuÃ§Ã£o iremos aplicar a otimizaÃ§Ã£o -O4 (o que significa otimizaÃ§Ã£o agressiva). EntÃ£o execute os seguintes comandos para realizar o processo de compilaÃ§Ã£o:

```bash
# Novamente, prog0 e prog4 foram os nomes que eu utilizei. Poderia ser qualquer 
#outro nome.
# prog0 foi porque nÃ£o tem nenhuma otimizaÃ§Ã£o
# prog4 foi porque eu usei a otimizaÃ§Ã£o mÃ¡xima, no caso Ã© 4

gcc -o prog0 -O0 arquivo.c
gcc -o prog4 -O4 arquivo.c
```

- **(1) Informe a diferenÃ§a de performance entre os dois programas usando a mÃ©dia (de pelo menos 3 execuÃ§Ãµes) e o desvio padrÃ£o para ambas mÃ©tricas (tempo de execuÃ§Ã£o e IPC).**

Para isso, use a ferramenta **perf**, que oferece informaÃ§Ãµes tanto do IPC (instruÃ§Ãµes por ciclo) quanto de tempo de execuÃ§Ã£o.Â  Para isso execute o comando:

```bash
sudo perf stat -e instructions,cycles ./prog0
sudo perf stat -e instructions,cycles ./prog4
```

- **(2) O que vocÃª acha que pode mudar entre uma otimizaÃ§Ã£o e outra ? Pesquise porque nem sempre os programas sÃ£o compilados com a otimizaÃ§Ã£o mÃ¡xima ?**
- **(3) Aproveite as informaÃ§Ãµes dadas pelo perf como a mÃ©trica IPC, total instruÃ§Ãµes e total de ciclos para verificar se o resultado do tempo de execuÃ§Ã£o se aproxima da fÃ³rmula descrita inicialmente nesse documento.**
    - Lembre-se que o perf irÃ¡ mostrar a mÃ©trica IPC, porÃ©m a fÃ³rmula usa CPI. Para fazer a conversÃ£o basta fazer a seguinte conta: CPI = 1/IPC.
    [Estimando o Tempo de 1 Ciclo](https://www.notion.so/Estimando-o-Tempo-de-1-Ciclo-e4ede2b68beb480595ce4a9b32ce0c6a?pvs=21)

# PrÃ¡tica 3 - Diferentes Processadores

O propÃ³sito do terceiro experimento Ã© analisar o impacto que o **hardware** tem sobre a performance de uma aplicaÃ§Ã£o. Para isso, nÃ³s vamos usar o **mesmo tipo de algoritmo**, o **mesmo tipo de linguagem de programaÃ§Ã£o**, **o mesmo processo de compilaÃ§Ã£o**, porÃ©m **simularemos dois hardwares diferentes**. Mudaremos apenas um item do hardware, a sua frequÃªncia de trabalho.

Cada CPU possui uma lista de frequÃªncia Ã s quais ele suporta trabalhar. NÃ³s iremos usar duas dessas frequÃªncias. A frequÃªncia menor para simular um hardware mais "fraco"e depois nÃ³s iremos usar a frequÃªncia maior para simular um hardware mais "forte". Para listar as frequÃªncias suportadas, utilize o seguinte comando no **terminal**:

```bash
cpufreq-info
```

Antes de configurar uma frequÃªncia especÃ­fica, mudaremos a polÃ­tica de configuraÃ§Ã£o de frequÃªncia para trabalhar de maneira fixa e nÃ£o dinÃ¢mica como normalmente Ã© o comportamento padrÃ£o. Para isso, execute no terminal o seguinte comando, mudando a polÃ­tica para **performance**.

```bash
sudo cpufreq-set -r -g performance
```

Confirme atravÃ©s do comando abaixo que a frequÃªncia estÃ¡ na mÃ¡xima.

```bash
watch cat /sys/devices/system/cpu/cpu[0-9]*/cpufreq/scaling_cur_freq
```

Se por algum motivo a configuraÃ§Ã£o nÃ£o surtir efeito, vocÃª pode tentar atravÃ©s de um aplicativo com interface chamado **cpupower-GUI** usando os links abaixo. PorÃ©m, caso esteja funcionando, apenas pule essa etapa.

[cpupower-GUI](https://github.com/vagnum08/cpupower-gui/releases/)

Aqui algumas instruÃ§Ãµes de como instalÃ¡-lo:

[cpupower-gui-simple-tool-adjust-cpu-frequency](https://ubuntuhandbook.org/index.php/2020/11/cpupower-gui-simple-tool-adjust-cpu-frequency/)

Em seguida vocÃª deve rodar o seu programa em C feito em **PrÃ¡tica 1** e coletar o tempo de execuÃ§Ã£o.

```bash
time ./prog 
```

Depois, vocÃª deve repetir esse processo, porÃ©m configurando a CPU para trabalhar na frequÃªncia mÃ­nima. Para isso mude a polÃ­tica para **powersave**.

```bash
# Assumindo que a frequÃªncia mÃ¡xima seja 3.6GHz
sudo cpufreq-set -r -g powersave
```

Confirme atravÃ©s do comando abaixo que a frequÃªncia estÃ¡ na mÃ­nima.

```bash
watch cat /sys/devices/system/cpu/cpu[0-9]*/cpufreq/scaling_cur_freq
```

Novamente vocÃª deve coletar o tempo de execuÃ§Ã£o e depois comparar qual foi o ganho de performance entre as duas execuÃ§Ãµes.

```bash
time ./prog
```

- **(1) Informe a diferenÃ§a de performance entre as duas execuÃ§Ãµes, usando a mÃ©dia (de pelo menos 3 execuÃ§Ãµes) e apresente tambÃ©m o desvio padrÃ£o dos resultados.**
- **(2) Como foi a diferenÃ§a de performance em relaÃ§Ã£o a diferenÃ§a de frequencia ?**

Ã‰ importante destacar que a frequÃªncia da CPU afeta a velocidade de execuÃ§Ã£o das instruÃ§Ãµes e, consequentemente, o tempo total de execuÃ§Ã£o do programa. Ela nÃ£o afeta o nÃºmero absoluto de instruÃ§Ãµes em um programa, mas pode influenciar a quantidade de instruÃ§Ãµes executadas em um determinado perÃ­odo de tempo.

Ao final, deixe a frequencia de trabalho dinÃ¢mica, usando o seguinte comando:

```bash
sudo cpufreq-set -r -g ondemand
```